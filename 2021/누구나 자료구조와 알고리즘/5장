# 5장. 빅 오를 사용하거나 사용하지 않는 코드 최적화



## 빅 오 표기법상 같다고 성능이 다 같은 것이 아니다.

### 선택정렬과 버블정렬

|            | 선택 정렬                                                    | 버블 정렬                                                    |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 빅 오 표기 | O(n<sup>2</sup>)                                             | O(n<sup>2</sup>)                                             |
| 애니메이션 | <img src="https://camo.githubusercontent.com/38b9ee71158705c9efe4094fb2ede36f21c1ac52ab6bc5bdc766859549db668e/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f622f62302f53656c656374696f6e5f736f72745f616e696d6174696f6e2e676966" alt="img" style="zoom:50%;" /> | <img src="https://camo.githubusercontent.com/0531061cee46dd752502b85ce6258aca25ae52038c7f4d698ffc89ad4f66f09e/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f332f33372f427562626c655f736f72745f616e696d6174696f6e2e676966" alt="img" style="zoom:55%;" /> |
| N개의 원소 | 최대 단계 수                                                 | 최대 단계 수                                                 |
| 5          | 14                                                           | 20                                                           |
| 10         | 54                                                           | 90                                                           |
| 20         | 199                                                          | 380                                                          |
| 40         | 819                                                          | 1560                                                         |
| 80         | 3239                                                         | 6320                                                         |



선택정렬이 2배 가량 더 빠르지만 빅 오 표기법상 같은 방식으로 설명한다.

>  빅 오 표기법은 데이터 원소 수에 비례해 얼마나 많은 단계 수가 필요한가를 기술한 것.

### 빅 오 표기법은 상수를 무시한다.

O(N<sup>2</sup>) == O(N<sup>2</sup> / 2)

같은 O(N<sup>2</sup>) 알고리즘이지만 후자는 전자보다 2배 빠르다.

O(100N) == O(2N) == O(N) == O(N / 2)

같은 O(N)으로 분류되어도 100배 느릴 수도 2배 빠를수도.

### 빅 오는 알고리즘의 장기적인 증가율을 분류하는 방법

어느 정도 크기의 데이터에 대해서는 O(N)이 항상 O(N<sup>2</sup>)보다 빠르다. O(N)에서 N이 100N이어도 상관없이 그렇다.

지수적으로 증가하는가 / 선형적으로 증가하는가

어떤 시점까지는 당장에 필요한 단계 수가 많은 100N의 알고리즘이 더 느릴 수 있지만 그 시점이 지나고 나면 항상 N제곱 알고리즘보다 더 빠르다.

### 결론

알고리즘을 선택할 때 두 알고리즘이 같은 분류에 속한다면 어떤 알고리즘이 더 빠를지 알기 위해 분석해야 한다.

