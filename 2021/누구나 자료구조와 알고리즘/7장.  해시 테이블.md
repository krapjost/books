# 7장. 해시 테이블로 매우 빠른 룩업



 제품마다 다른 가격을 가지고 있는 데이터가 있다.

이때 배열을 사용할 경우 비효율적이다.

```javascript
const prod = [['운동화', 1000], ['구두', 2000], ['농구공', 3000]]
```

제품 구매가 발생했을 때 어떤 제품을 구매했는지 찾아야 할 때 일일이 순회해야 하기 때문이다. 정렬된 배열의 경우라도 log N의 복잡도로 이뤄진다.

이 때 해시 테이블을 사용하면 O(1) 만에 검색할 수 있게 된다.

## 해시 테이블이란

해시 테이블은 여러 프로그래밍 언어에서 다른 이름으로 불린다.

해시, 맵, 해시 맵, 딕셔너리, 연관 배열 등의 이름을 갖는다.

해시 테이블은 키와 값의 쌍으로 이뤄진 값들의 리스트이다.

```javascript
const menu = {'운동화': 1000, '농구공': 2000};
const ball = menu['농구공'];
```

이런식으로 해당 키의 값을 한 번에 찾아볼 수 있다.

### 해싱이란?

​	문자를 가져와 숫자로 변환하는 과정을 **해싱**이라 부른다.

​	글자를 특정 숫자로 변환하는 데 사용한 코드를 **해시 함수**라고 부른다.



해시함수가 유효하려면 다음 한 가지 기준을 충족해야 한다.

>  해시 함수는 **동일한 문자열**을 해시 함수에 적용할 때마다 항상 **동일한 숫자**로 변환해야 한다.

```javascript
// 의사 코드
const hash = {a = 1, b = 2, c = 3, d = 4, e = 5};
const hashFunc = (key) => {
    return +key.split('').map(x=>{
        return hash[x]
    }.join('')
}
hashFunc('bad')
// return : 214

```

hashFunc에 각 키에 해당하는 값으로 덧셈, 곱셈 등 어떤 연산을 사용해 해시값을 만들어도  되지만 같은 값을 주었을 때 항상 나오는 값이 동일해야 한다. 따라서 항상 변하는 datetime 등의 값을 연산 과정에 넣어선 안된다.

해시 테이블은 내부적으로 데이터를 한 줄로 이뤄진 셀 묶음에 저장한다. 그리고 각 셀마다 주소가 있다.

```javascript
const hashTable = {}
```

|      |      |      |      |      |      |      |      |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |

```javascript
hashTable['iu'] = "아이유"
```

|      |      |      | '아이유' |      |      |      |      |
| :--: | :--: | :--: | :------: | :--: | :--: | :--: | :--: |
|  1   |  2   |  3   |    4     |  5   |  6   |  7   |  8   |

해싱 함수가 키 'iu' 를 받았을 때 나오는 값이 4라면 4번 메모리 주소 에 값 '아이유'가 들어간다.

### 해시테이블의 문제

```javascript
hashTable['ui'] = '유아인'
```

만약에 해싱 함수가 곱셈을 사용하여 스펠링 순서 차이는 상관하지 않고 같은 값(메모리 번지 수)를 뱉어낸다면 이미 '아이유'가 들어가 있는 4번 메모리 주소에 '유아인'를 넣으려고 할 것이다.

이를 **충돌**이라고 부른다.

### 충돌 해결법

* 분리 연결법

 충돌이 발생했을 때 셀에 **하나의 값**을 넣는 대신 **<u>배열</u>**로의 참조를 넣는 방법.

```javascript
// 의사코드
cosnt eg = {[{'iu':'아이유'}, {'ui': '유아인'}]}
```

이 때 'ui'를 찾으려고 하면 컴퓨터는 같은 4번 번지수를 먼저 찾고 거기에 저장된 값이 단일 값이 아닌 **<u>배열이라면</u>** 'ui'를 찾을 때까지 배열을 차례대로 선형 검색한다.

이러한 방법을 사용했을 때 또한 최악의 상황을 고려해보면 사실상 배열 선형검색 O(N) 과 다를 바 없다. 같은 메모리 주소에 모든 데이터가 들어갈 경우도 있을 것이기 때문이다.



### 충돌이 적게 일어나게 해시 테이블을 구현하려면?

좋은 해시함수는 **사용 가능한 모든 셀**에 데이터를 분산시키는 함수이다.

좋은 해시 테이블은 반드시 충돌 조정을 수행해야 한다.

좋은 해시 테이블은 많은 메모리를 낭비하지 않으면서 충돌을 피한다.



### 데이터와 셀 간의 비율

데이터와 셀 간의 비율을 부하율이라고 한다.

원소 7 대 셀 10 개의 비율이 이상적이다.

해시 테이블 내부는 대부분 컴퓨터 언어에서 관리하므로 원리 이해를 위한 목적이 아니면 구현할 필요는 없을 것이다.

